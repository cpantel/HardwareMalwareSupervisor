const Monitor = require('./monitor2');

function Bus() {
  var value = 0;
}

function RAM(dataBus, addressBus, readSignal, writeSignal) {
  this.dataBus     = dataBus;
  this.addressBus  = addressBus;
  this.readSignal  = readSignal;
  this.writeSignal = writeSignal;
  this.memory = [
    /* 00 00 */    0x00,    // memory mapped GPIO
    /* 01 01 */    0x00,
    /* 02 02 */    0x00,
    /* 03 03 */    0x00,
    /* 04 04 */    0x00,
    /* 05 05 */    0x00,
    /* 06 06 */    0x00,
    /* 07 07 */    0x00,
    /* 08 08 */    0x00,
    /* 09 09 */    0x00,
    /* 0A 10 */    0x00,
    /* 0B 11 */    0x00,
    /* 0C 12 */    0x00,
    /* 0D 13 */    0x00,
    /* 0D 14 */    0x00,
    /* 0F 15 */    0x2e,    //  SVC address (46)

    /* 10 16 */    0x90,    //  init: nop            
    /* 11 17 */    0x90,    //        nop
    /* 12 18 */    0x90,    //        nop
    /* 13 19 */    0x90,    //        nop             
    /* 14 20 */    0x90,    //        nop
    /* 15 21 */    0x90,    //        nop

    /* 16 22 */    0x25,    //        set b0101      legal out
    /* 17 23 */    0x40,    //        svc            legal out 
    /* 18 24 */    0x2A,    //        set b1010      legal out
    /* 19 25 */    0x40,    //        svc            legal out
    /* 1A 26 */    0x2F,    //        set b1111      legal out
    /* 1B 27 */    0x40,    //        svc            legal out

    /* 1C 28 */    0x25,    //        set b0101      failed out
    /* 1D 29 */    0x30,    //        out            failed out
    /* 1E 30 */    0x2A,    //        set b1010      failed out
    /* 1F 31 */    0x30,    //        out            failed out
    /* 20 32 */    0x2F,    //        set b1111      failed out
    /* 21 33 */    0x30,    //        out            failed out

    /* 22 34 */    0x20,    //        set b0000      troyan activation
    /* 23 35 */    0x80,    //  loop: inc            troyan activation
    /* 24 36 */    0x90,    //        nop            troyan activation
    /* 25 37 */    0x1F,    //        jnz loop       troyan activation

    /* 26 38 */    0x25,    //        set b0101      exploitation
    /* 27 39 */    0x30,    //        out            exploitation
    /* 28 40 */    0x2A,    //        set b1010      exploitation
    /* 29 41 */    0x30,    //        out            exploitation
    /* 2A 42 */    0x2F,    //        set b1111      exploitation
    /* 2B 43 */    0x30,    //        out            exploitation

    /* 2C 44 */    0x90,    //        nop            
    /* 2D 45 */    0x70,    //        hlt            
    /* 2E 46 */    0x30,    //  svc:  out            svc         
    /* 2F 47 */    0x00     //        ret            svc
  ];
}

RAM.prototype.posedge = function() {
  if (this.readSignal.value) {
    this.dataBus.value = this.memory[this.addressBus.value];
  } else if (this.writeSignal.value) {
    this.memory[this.addressBus.value]= this.dataBus.value;
  }
}

RAM.prototype.getGPIO = function() {
  return this.memory[0];
}

function AddressALU() {
  var operand1;
  var operand2;
  var opcode;
  var result;
}

AddressALU.prototype.posedge = function() {
  switch (this.opcode) {
    case "ALU_u4add": 
      if (this.operand2 > 7) {
        this.result = this.operand1 += ( this.operand2 - 17);
      } else {
        this.result = this.operand1 += this.operand2;
      }
    break; 
    case "ALU_u8inc":
      this.result = this.operand1 + 1;
    break;
    case undefined:

    break;
    default: 
      throw "AddressALU unknown opcode: " + this.opcode;
    break;
  }
}

function ALU() {
  var operand1;
  var opcode ;
  var result;
  var zero;
}

ALU.prototype.posedge = function () {
  switch (this.opcode) {   
    case "ALU_inc":
      this.result = this.operand1 + 1;
      if ( this.result > 255) this.result -= 256;
      this.zero = (this.result == 0);
    break;
    case undefined:

    break;
    default:
      throw "ALU unknown opcode: " + this.opcode; 
    break;
  }
}

function CPU(dataBus, addressBus, readSignal, writeSignal) {
  this.A               = 0;
  this.RA              = 0;
  this.PC              = 16;
  this.supervisor      = false;
  this.error           = 0;
  this.lastPC          = 0;

  this.opcode          = "";
  this.opcodeName      = "";
  this.data            = 0;

  this.dataBus         = dataBus;
  this.addressBus      = addressBus;
  this.readSignal      = readSignal;
  this.writeSignal     = writeSignal;

  this.AddressALU      = new AddressALU();
  this.ALU             = new ALU();

  this.state           = "fetch";
}

CPU.prototype.posedge = function() {
  if (this.error > 0) this.error--;

  switch (this.state) {
    case "fetch":
      this.addressBus.value = this.PC;
      this.readSignal.value = true;
      this.state = "fetch_return";
    break;
    
    case "fetch_return":
      this.lastPC = this.PC;
      this.opcode = Math.floor(this.dataBus.value / 16);
      this.data = this.dataBus.value % 16;
      this.readSignal.value = false;
      this.state = "decode";
    break;

    case "next_instruction_address":
      this.PC = this.AddressALU.result;
      this.state = "fetch";
    break;

    case "branching":
      this.PC = this.AddressALU.result;
      this.state = "fetch";
    break;

    case "write_to_ram":
      this.AddressALU.operand1 = this.PC;
      this.AddressALU.opcode = "ALU_u8inc";
      this.writeSignal.value = false;
      this.state = "next_instruction_address";
    break;

    case "read_from_ram":
      this.PC = this.dataBus.value;
      this.readSignal.value = false;
      this.state = "fetch";
    break;

    case "store_return_address":
      this.RA = this.AddressALU.result;
      this.addressBus.value = 0x0F;
      this.readSignal.value = true;
      this.state = "read_from_ram";
    break;

    case "inc_a":
      this.A = this.ALU.result;
      this.AddressALU.operand1 = this.PC;
      this.AddressALU.opcode = "ALU_u8inc";
      this.state = "next_instruction_address";
    break;

    case "decode":
      switch (this.opcode) {
        case 0:
          this.opcodeName = "CPU_ret";
          this.supervisor = false;
          this.PC = this.RA;
          this.state = "fetch";
        break;

        case 1:
          this.opcodeName = "CPU_jnz";
          if ( ! this.ALU.zero) {
            this.AddressALU.operand1 = this.PC;
            this.AddressALU.operand2 = this.data;
            this.AddressALU.opcode = "ALU_u4add";
            this.state = "branching"
          } else {
            this.AddressALU.operand1 = this.PC;
            this.AddressALU.opcode = "ALU_u8inc";
            this.state = "next_instruction_address"  
          }
        break;

        case 2:
          this.opcodeName = "CPU_set";
          this.A = this.data;
          this.AddressALU.operand1 = this.PC;
          this.AddressALU.opcode = "ALU_u8inc";
          this.state = "next_instruction_address";
        break;

        case 3:
          this.opcodeName = "CPU_out";
          if ( this.supervisor) {
            this.addressBus.value = 0;
            this.dataBus.value = this.A;
            this.writeSignal.value = true;
            this.state = "write_to_ram";
          } else {
            this.error = 4;
            this.AddressALU.operand1 = this.PC;
            this.AddressALU.opcode = "ALU_u8inc";
            this.state = "next_instruction_address";
          }
        break;

        case 4:
          this.opcodeName = "CPU_svc";
          this.supervisor = true;
          this.AddressALU.operand1 = this.PC;
          this.AddressALU.opcode = "ALU_u8inc";
          this.state = "store_return_address";
        break;

        case 7:
          this.opcodeName = "CPU_hlt";
          this.state = "halt";
        break;

        case 8:
          this.opcodeName = "CPU_inc";
          this.ALU.operand1 = this.A;
          this.ALU.opcode = "ALU_inc";
          this.state = "inc_a";
        break;

        case 9:
          this.opcodeName = "CPU_nop";
          this.AddressALU.operand1 = this.PC;
          this.AddressALU.opcode = "ALU_u8inc";
          this.state = "next_instruction_address";
        break;
      }
    break;

    default:
      throw "Unknown state: " + this.state;
    break;
  }
  return (this.state == "halt");
}

CPU.prototype.getZero = function() {
  return this.ALU.zero;
}

function Malware(cpu) {
  this.backdoorTrigger = 0;
  this.cpu = cpu;
}

Malware.prototype.posedge = function() {
  if (Math.floor(this.cpu.opcode / 8) ) {
    this.backdoorTrigger++;
    if (this.backdoorTrigger > 700) {
      this.cpu.supervisor = true;
    }
  } else if ( this.backdoorTrigger > 0) {
    this.backdoorTrigger--;
  }
}

function Board() {
  this.dataBus = new Bus();
  this.addressBus = new Bus();
  this.readSignal = new Bus();
  this.writeSignal = new Bus();

  this.RAM = new RAM(this.dataBus, this.addressBus, this.readSignal, this.writeSignal)
  this.CPU = new CPU(this.dataBus, this.addressBus, this.readSignal, this.writeSignal);
  this.troyan = new Malware(this.CPU);
  this.monitor = new Monitor(this.CPU, this.RAM, this.troyan);
}

Board.prototype.run = function() {
  var exit = false;

  while (! exit) {
    exit = this.CPU.posedge();
    this.CPU.ALU.posedge();
    this.CPU.AddressALU.posedge();
    this.RAM.posedge();
    this.troyan.posedge();
    this.monitor.show();
  }
}

var board = new Board();
board.run();

